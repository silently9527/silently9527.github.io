#### 对象声明
单例对象在面向对象编程中很常见, 在Java中通常都是使用单例模式来实现的, 在Kotlin中可以简单的使用一个 `object` 关键字来实现, `object` 表示定义一个类并且同时创建一个实例,所以使用`object`标记的类其实就是一个对象, 先来看个例子

```
data class User(val name: String)

object UserFactory {
    fun createUser(name: String): User = User(name)
}

fun main(args: Array<String>) {
    val user = UserFactory.createUser("Herman")
    println(user)
}
```

使用场景：
- 全局唯一实例：当需要一个全局唯一的对象时，可以使用对象声明。例如，用于管理全局状态、单例模式、工具类等。
- 无状态的工具类：可以把一组相关的函数放到一个对象声明中，这样可以避免创建类的实例，并且方便调用。

#### 匿名内部类
`object`关键字不仅可以用来声明单例模式的对象,还可以用来声明匿名内部类. 来看看Button如何处理点击事件
```
Button().addActionListener(object : ActionListener {
    override fun actionPerformed(e: ActionEvent?) {
    }
})
```

> 注意: 与对象声明不同的是匿名内部类不是单例的, 每次执行的时候都会创建一个新的对象实例子


#### 伴生对象

Kotlin中类不能够拥有静态成员; 替代的方案:使用包级别的函数和对象声明, 但是顶层的函数不能够访问到类的private成员,这时候就需要使用到伴生对象, 关键字`companion`

伴生对象是类内部的一个对象声明，它与外部类相关联，并且可以访问外部类的私有成员。Kotlin 中的伴生对象类似于 Java 中的静态成员，尽管它不是静态的，但可以像静态方法和属性一样使用。

使用场景：
- 工厂方法：使用伴生对象创建类的实例，而不是直接调用构造函数。
- Java静态成员替代：将需要静态访问的属性和方法放在伴生对象中，这样可以在不创建类实例的情况下访问它们。
- 与类紧密关联的功能：当某些功能与类本身相关而不是与实例相关时，可以放在伴生对象中

```
class User private constructor(private val name: String) {
    companion object UserFactory {
        fun createUser(name: String): User {
            val user = User(name)
            println(user.name)
            return user
        }
    }
}
```
注意看上面的例子,如果不是使用伴生对象是没有办法访问到User的私有构造方法和私有变量; 伴生对象的名字可以省略,默认的名字将会是`Companion`



原文链接: [http://herman7z.site](http://herman7z.site)



