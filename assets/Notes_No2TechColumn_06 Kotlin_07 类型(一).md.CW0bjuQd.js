import{_ as a,c as s,o as n,aa as e}from"./chunks/framework.DOnJscRE.js";const b=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"Notes/No2TechColumn/06 Kotlin/07 类型(一).md","filePath":"Notes/No2TechColumn/06 Kotlin/07 类型(一).md","lastUpdated":1761049051000}'),p={name:"Notes/No2TechColumn/06 Kotlin/07 类型(一).md"},t=e(`<h4 id="可空性" tabindex="-1">可空性 <a class="header-anchor" href="#可空性" aria-label="Permalink to &quot;可空性&quot;">​</a></h4><p>Kotlin允许对变量声明是否能够为空,如果某个变量被定义成可空,那么调用这个变量就是不安全的,可能会出现NullpointerException, 所以Kotlin在编译期间就会检查.</p><p>定义允许变量为空,是在类型后面添加<code>?</code></p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>val name:String?</span></span></code></pre></div><blockquote><p>注意: 没有问号的变量是不能够设置为null, 这说明Kotlin默认变量就是不能为空</p></blockquote><h4 id="安全调用运算符" tabindex="-1">安全调用运算符 <a class="header-anchor" href="#安全调用运算符" aria-label="Permalink to &quot;安全调用运算符&quot;">​</a></h4><p>在Java中,如果一个对象可能为空,那么我们在调用之前需要先判断是这个对象是否为空,比如下面的例子:</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>fun toUppercase(name: String?): String? {</span></span>
<span class="line"><span>    if (name == null) {</span></span>
<span class="line"><span>        return null</span></span>
<span class="line"><span>    } else {</span></span>
<span class="line"><span>        return name.uppercase()</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span>}</span></span></code></pre></div><p>上面的例子Koltin可以使用安全调用运算符 <code>?.</code> 来简写</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>fun toUppercase(name: String?): String? {</span></span>
<span class="line"><span>    return  name?.uppercase()</span></span>
<span class="line"><span>}</span></span></code></pre></div><p>允许多个安全调用链接调用</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>name?.uppercase()?.substring(0)</span></span></code></pre></div><h4 id="elvis运算符" tabindex="-1">Elvis运算符 <a class="header-anchor" href="#elvis运算符" aria-label="Permalink to &quot;Elvis运算符&quot;">​</a></h4><p>在上面的例子,使用了<code>?.</code>安全调用后,如果是空就会返回null, 若你需要返回一个指定的默认值就可以使用Elvis运算符 <code>?:</code>; Elvis运算符通常和安全调用一起使用</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>fun toUppercase(name: String?): String? {</span></span>
<span class="line"><span>    return name?.uppercase() ?: &quot;NONE&quot;</span></span>
<span class="line"><span>}</span></span></code></pre></div><h4 id="安全转换" tabindex="-1">安全转换 <a class="header-anchor" href="#安全转换" aria-label="Permalink to &quot;安全转换&quot;">​</a></h4><p>Kotlin中类型转换使用 <code>as</code> 关键字, 如果出现了类型不匹配的时候就会抛出<code>ClassCastException</code>, 当然也可以是用<code>is</code>来检查类型是否合适. 还有一种简洁的方式就是 <code>as?</code>, 如果类型不匹配就会返回null; 通常也是和Elvis运算符一起使用</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>fun toUppercase(name: Any?): String? {</span></span>
<span class="line"><span>    return name as? String ?: &quot;NONE&quot;</span></span>
<span class="line"><span>}</span></span></code></pre></div><h4 id="非空断言" tabindex="-1">非空断言 <a class="header-anchor" href="#非空断言" aria-label="Permalink to &quot;非空断言&quot;">​</a></h4><p>有时候想要把变量转换成非空变量,可以使用<code>!!</code>, 如果变量的值确实是null, 那么就会抛出异常 <code>NullPointerExcetpion</code>, <strong>慎用</strong></p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>fun toUppercase(name: String?): String? {</span></span>
<span class="line"><span>    return name!!.uppercase()</span></span>
<span class="line"><span>}</span></span></code></pre></div><h4 id="let函数" tabindex="-1">let函数 <a class="header-anchor" href="#let函数" aria-label="Permalink to &quot;let函数&quot;">​</a></h4><p>假如我们这里有一个方法发送消息函数, msg参数是非空参数</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>fun sendMsg(msg:String){</span></span>
<span class="line"><span>    // ...</span></span>
<span class="line"><span>}</span></span></code></pre></div><p>当我们把可空的参数传递给这个函数就会编译报错,必须显示的判断参数是否为空</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>var msg: String? = &quot;Test&quot;</span></span>
<span class="line"><span>if (msg != null) {</span></span>
<span class="line"><span>    sendMsg(msg)</span></span>
<span class="line"><span>}</span></span></code></pre></div><p>除了上面的这种写法还可以使用let函数来改写</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>msg?.let { sendMsg(it) }</span></span></code></pre></div><h4 id="延迟初始化属性" tabindex="-1">延迟初始化属性 <a class="header-anchor" href="#延迟初始化属性" aria-label="Permalink to &quot;延迟初始化属性&quot;">​</a></h4><p>Koltin通常要求你在构造方法中初始化所有的属性,如果有个属性是非空类型,你就必须提供非空的初始化值,否则就必须使用可空类型. 如果这样做,该属性每次访问的时候都需要if 进行 null检查 或者使用 <code>!!</code> 运算符</p><p>为了解决这个问题Kotlin提供了关键字 <code>lateinit</code></p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>class Person(val name: String, val age: Int) {</span></span>
<span class="line"><span>    private lateinit var address: String</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    fun setUp() {</span></span>
<span class="line"><span>        address = &quot;Beijing&quot;</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span></span></span>
<span class="line"><span>}</span></span></code></pre></div><blockquote><ol><li>延迟初始化的属性都是<code>var</code>, 因为需要在构造方法以外的地方修改它的值; 而<code>val</code>属性必须在构造函数中初始化,会被编译成final字段; 如果被<code>lateinit</code>声明的字段在初始化之前就被访问就会得到异常提示还未被初始化. <code>lateinit</code>属性常用于依赖注入.</li><li>null对象是可以调用扩展函数的, 因为扩展函数会被编译成静态的Java方法, 需要在扩展函数中检查null</li></ol></blockquote><h4 id="泛型类型" tabindex="-1">泛型类型 <a class="header-anchor" href="#泛型类型" aria-label="Permalink to &quot;泛型类型&quot;">​</a></h4><p>泛型类型参数默认都是可空的,所以在调用的时候需要使用安全调用.</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>fun &lt;T : Person?&gt; printName(t: T) {</span></span>
<span class="line"><span>    println(t?.name)</span></span>
<span class="line"><span>}</span></span></code></pre></div><p>原文链接: <a href="http://herman7z.site" target="_blank" rel="noreferrer">http://herman7z.site</a></p>`,37),l=[t];function i(o,c,d,r,h,u){return n(),s("div",null,l)}const v=a(p,[["render",i]]);export{b as __pageData,v as default};
