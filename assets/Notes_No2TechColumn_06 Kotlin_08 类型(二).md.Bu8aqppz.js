import{_ as a,c as n,o as e,aa as s}from"./chunks/framework.DOnJscRE.js";const b=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"Notes/No2TechColumn/06 Kotlin/08 类型(二).md","filePath":"Notes/No2TechColumn/06 Kotlin/08 类型(二).md","lastUpdated":1761042589000}'),l={name:"Notes/No2TechColumn/06 Kotlin/08 类型(二).md"},t=s(`<h4 id="基础数据类型" tabindex="-1">基础数据类型 <a class="header-anchor" href="#基础数据类型" aria-label="Permalink to &quot;基础数据类型&quot;">​</a></h4><p>众所周知,Java把数据类型分为了基本数据类型和引用类型,基本数据类型的变量直接存储了它的值在栈上分配;而引用类型的变量在堆上分配,持有对象地址的引用. Java还对基础数据类型进行了包装, 比如: <code>Integer</code> <code>Long</code></p><p>Kotlin并不区分基础数据类型和包装类型,使用的都是同一对象,比如 <code>Int</code>; 由于Kotlin代码最终会编译成Java,若都编译成包装类型那效率会很低效,所以在编译的时候Kotlin尽量将类型 Int 编译成基础数据类型 int; 唯一例外是泛型类</p><p>基础数据类型:</p><ul><li>整数类型 Byte、Int、Long、Short</li><li>浮点类型 Float、Double</li><li>字符类型 Char</li><li>布尔类型 Boolean</li></ul><p>在java中基础数据类型不能存储null值, 所以在Koltin中如果使用了可空的数据类型定义,比如:<code>Int?</code>, 他就会被编译成对应的包装类型</p><h4 id="数字类型转换" tabindex="-1">数字类型转换 <a class="header-anchor" href="#数字类型转换" aria-label="Permalink to &quot;数字类型转换&quot;">​</a></h4><p>Kotlin不会自动把数字从一种类型转换成另一种类型,即使是转换成范围更大的类型, 例如:</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>var i: Int = 1</span></span>
<span class="line"><span>var z: Long = i</span></span></code></pre></div><p>这段代码编译时会报错, 必须调用<code>i.toLong()</code>显示的转换成Long</p><p>当书写数字的字面值的时候,不用显示调用转换,程序依然能够正常运行, 是由于Kotlin能够推断出类型, 比如:</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>val list = listOf(1L, 2L)</span></span>
<span class="line"><span>print(1 in list)</span></span></code></pre></div><p>这段代码能够正常执行, 由于<code>in</code>关键字实际调用的是<code>list.contains</code>, 这个方法的参数已经确定是Long</p><h4 id="any" tabindex="-1">Any <a class="header-anchor" href="#any" aria-label="Permalink to &quot;Any&quot;">​</a></h4><p>Any和java中Object差不多,是所有非空类型的根类, 如果把基础数据类型值赋值给Any对象,那么变量会自动装箱</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>var x: Any = 1</span></span></code></pre></div><p>当你需要Any变量持有null值的时候,需要使用<code>Any?</code></p><h4 id="unit" tabindex="-1">Unit <a class="header-anchor" href="#unit" aria-label="Permalink to &quot;Unit&quot;">​</a></h4><p>Unit类型的功能与Java中void的功能一样,当函数没有返回值的时候可以使用<code>Unit</code>, 当然也可以不用写. 下面来看一个Unit的使用场景</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>interface Processor&lt;T&gt; {</span></span>
<span class="line"><span>    fun process(): T</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span>
<span class="line"><span>class DefaultProcessor : Processor&lt;Unit&gt;{</span></span>
<span class="line"><span>    override fun process() {</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span>}</span></span></code></pre></div><p>DefaultProcessor 指定了泛型为Unit, 所以在实现process方法的时候不需要再写return</p><h4 id="集合可空性" tabindex="-1">集合可空性 <a class="header-anchor" href="#集合可空性" aria-label="Permalink to &quot;集合可空性&quot;">​</a></h4><p>在使用集合的时候,可以控制集合中的元素是否允许为空,比如:<code>ArrayList&lt;Int?&gt;</code>, 当然也可以控制整个集合对象是否允许为空</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>var list: List&lt;Int?&gt;?</span></span></code></pre></div><p><img src="https://cdn.jsdelivr.net/gh/silently9527/images//202409121138448.png" alt=""></p><ul><li>第一种情况: 集合本身不能为null, 但是其中的元素可能是null</li><li>第二种情况: 集合本身可能是null, 其中的元素不能为null</li></ul><p>集合提供了函数<code>filterNotNull</code>来过滤掉集合中的空值</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>val list = listOf(1L, 2L, null)</span></span>
<span class="line"><span>print(list.filterNotNull())</span></span></code></pre></div><h4 id="只读集合与可变集合" tabindex="-1">只读集合与可变集合 <a class="header-anchor" href="#只读集合与可变集合" aria-label="Permalink to &quot;只读集合与可变集合&quot;">​</a></h4><p>Kotlin集合设计与Java有点不同,它把集合接口分为了只读与可变.</p><ul><li>只读接口可以遍历,查询集合大小,判断是否包含某个元素等等,接口: <code>kotlin.collections.Collection</code></li><li>可变接口可以修改集合中的数据,添加元素,删除元素,清空集合等等,接口: <code>kotlin.collections.MutableCollection</code></li></ul><p>只读与可变接口的分离能够让程序更加清晰,比如方法的参数是只读接口,那么说明这个方法中只能读取集合不能修改集合</p><p><img src="https://cdn.jsdelivr.net/gh/silently9527/images//202409121208018.png" alt=""></p><h4 id="数组" tabindex="-1">数组 <a class="header-anchor" href="#数组" aria-label="Permalink to &quot;数组&quot;">​</a></h4><p>Kotlin中创建数组的三种方式:</p><ul><li>arrayOf 函数的参数为该数组的元素 <code>arrayOf(1, 2, 3)</code></li><li>arrayOfNulls 创建一个指定大小的数组,包含了null元素 <code>arrayOfNulls&lt;Int&gt;(3)</code></li><li>Array 构造方法接受数组的大小和一个lambda表达式, lambda表达式的参数是数组的大小 <code>Array(3) { it + 1 }</code></li></ul><p>数组类型的类型参数始终都会编译成对象类型, 即使数组的元素是基础数据类型也会被编译包装类型的数组; 如果需要使用没有包装类型的数组,需要使用Kotlin提供的特殊类,比如:<code>IntArray</code> <code>CharArray</code> <code>BooleanArray</code></p><p>创建一个int基础数据类型的数组</p><ul><li>IntArray的构造方法, 参数数组的大小和初始化元素的lambda表达式</li><li>intArrayOf方法, 参数数组的大小</li></ul><p>如果拥有一个持有基础数据类型的装箱类数组,可以把它转换成基础数据类型数组 比如: <code>arrayOf(1, 3).toIntArray()</code></p><p>遍历数组可以使用 <code>forEachIndexed</code></p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>arrayOf(1, 3).forEachIndexed { i, element -&gt;</span></span>
<span class="line"><span>    println(&quot;index: $i, element: $element&quot;)</span></span>
<span class="line"><span>}</span></span></code></pre></div>`,42),i=[t];function o(p,c,d,r,h,u){return e(),n("div",null,i)}const v=a(l,[["render",o]]);export{b as __pageData,v as default};
