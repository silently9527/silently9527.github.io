import{_ as e,c as i,o as a,aa as l}from"./chunks/framework.DOnJscRE.js";const u=JSON.parse('{"title":"10 事务","description":"","frontmatter":{"title":"10 事务","author":"Herman","updateTime":"2024-08-11 21:34","desc":"Mysql的事务","categories":"中间件","tags":"MySQL/InnoDB/B+树索引/Buffer Pool/事务","outline":"deep"},"headers":[],"relativePath":"Notes/No2TechColumn/07 MySql/10 事务.md","filePath":"Notes/No2TechColumn/07 MySql/10 事务.md","lastUpdated":1761830790000}'),t={name:"Notes/No2TechColumn/07 MySql/10 事务.md"},r=l('<h3 id="事务的4个特性-aicd" tabindex="-1">事务的4个特性 AICD <a class="header-anchor" href="#事务的4个特性-aicd" aria-label="Permalink to &quot;事务的4个特性 AICD&quot;">​</a></h3><ul><li>原子性(A): 一个事务中的操作要么全部成功，要么全部失败</li><li>隔离性(I): 两个事务之间互不影响</li><li>一致性(C): 通过数据库字段约束以及业务程序实现符合现实世界的约束</li><li>持久性(D): 一旦事务执行成功，那么结果就应该永久保存</li></ul><h3 id="redo日志" tabindex="-1">redo日志 <a class="header-anchor" href="#redo日志" aria-label="Permalink to &quot;redo日志&quot;">​</a></h3><p>前面的内容我们知道了Mysql修改数据的时候都是现在内存中修改，然后在刷新到磁盘上面，在刷新之前系统可能出现了故障导致内存中的数据丢失了，这该怎么办呢？ 简单粗暴的方法就是每次事务提交的时候就刷新数据到磁盘，这样也可以解决，但是存在两个问题：</p><ol><li>MySql与磁盘交互的最小单位是一个页，至少要刷新一个页面，太耗性能</li><li>随机IO刷新会很慢</li></ol><p>MySQL的做法是在事务提交的时候记录 哪个表空间中的 哪个页面及页面偏移量的数据需要修改成什么，这就是redo日志。如果系统出现了崩溃，在恢复后需要从redo日志中 重新执行更新逻辑</p><ul><li>redo日志占用的空间较小，只记录表空间ID，页号，偏移量以及需要修改的数据</li><li>redo日志是顺序写入到磁盘</li></ul><h3 id="事务的隔离级别" tabindex="-1">事务的隔离级别 <a class="header-anchor" href="#事务的隔离级别" aria-label="Permalink to &quot;事务的隔离级别&quot;">​</a></h3><p>事务在并发执行的时候会遇到一些问题</p><ul><li>脏写: 一个事务修改了另一个未提交事务的数据</li><li>脏读: 一个事务读取了另一个未提交事务的修改过的数据</li><li>不可重复读: 一个事务修改了另一个未提交事务读取的数据，导致未提交的事务两次读取的结果不一致</li><li>幻读: 一个事务根据某些条件查询出来了一些记录，另一个事务删除或插入了一条符合查询条件的数据。</li></ul><p>为了解决这些问题，SQL标准中定义了4中隔离级别</p><ul><li>read uncommitted: 解决脏写，可能出现脏读、不可重复读、幻读</li><li>read committed: 解决脏写、脏读，可能出现不可重复读、幻读</li><li>repeatable read: 解决脏写、脏读、不可重复读，可能出现幻读</li><li>serializable: 解决所有问题</li></ul><p>MySQL的默认隔离级别是 repeatable read.</p><p>设置事务的隔离级别命令：</p><div class="language-sql vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">sql</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">set</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> [global|session] </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">transaction</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> level</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> [read uncommitted|read committed|repeatable read|serializable]</span></span></code></pre></div><h3 id="mvcc原理" tabindex="-1">MVCC原理 <a class="header-anchor" href="#mvcc原理" aria-label="Permalink to &quot;MVCC原理&quot;">​</a></h3><p>innodb引擎的表，它的聚簇索引记录中都包含了下面两个必要的隐藏列：</p><ul><li>trx_id: 一个事务每次对某条记录进行修改的时候，都会把该事务的事务id设置给trx_id</li><li>roll_pointer: 每次对聚簇索引的记录进行修改的时候，都需要把旧的版本写入到undo日志中，这个roll_pointer就是指向这条旧的数据。</li></ul><p>每次对记录进行一次改动，都会记录一条undo日志，每条undo日志都会有trx_id、roll_pointer两个字段，roll_pointer指向更早的记录，这种机制就是多版本并发控制（MVCC）</p><p><img src="https://cdn.jsdelivr.net/gh/silently9527/images//202510302105819.png" alt=""></p><h3 id="mysql如何实现4种隔离级别" tabindex="-1">MySQL如何实现4种隔离级别 <a class="header-anchor" href="#mysql如何实现4种隔离级别" aria-label="Permalink to &quot;MySQL如何实现4种隔离级别&quot;">​</a></h3><p>read uncommitted: 由于允许读取到未提及事务的数据，所以事务直接读取MVCC的最新数据即可。</p><p>serializable: 这个级别就是要求所有事务串行执行，所以MySQL采用的是加锁的方式实现</p><p>read committed / repeatable read: 这两个隔离级别都不允许读取到未提交事务的数据，核心问题就是需要判断MVCC版本链中哪些数据是对当前事务可见，所以MySQL又引入了ReadView（一致性视图）</p><p>ReadView 主要4个字段：</p><ul><li>m_ids: 生成ReadView的时候，当前系统活跃的事务id列表</li><li>min_trx_id: 生成ReadView的时候，当前系统活跃最小事务id</li><li>max_trx_id: 生成ReadView的时候，系统应该分配给下一个事务的id</li><li>creator_trx_id: 生成ReadView的事务的事务id</li></ul><p>在访问某条记录的时候需要按照下面的步骤来判断：</p><ol><li>如果被访问记录的trx_id 和 ReadView中的creator_trx_id 值相同，那么表示当事务在访问它自己修改过的数据，允许访问</li><li>如果被访问记录的trx_id 小于 ReadView中的min_trx_id，说明生成该版本的事务在生成ReadView的时候已经提交，允许访问</li><li>如果被访问记录的trx_id 大于等于 ReadView中的max_trx_id，说明生成该版本的事务在生成ReadView的时候还未提交，不允许访问</li><li>如果被访问记录的trx_id在ReadView中的min_trx_id和max_trx_id之间，就需要判断记录的trx_id是否在m_ids的列表中，如果存在说明该版本的时候在生成ReadView的时候还未提交，不允许访问，如果不在则可以访问。</li></ol><p>当出现了不允许访问的时候就沿着版本链找上一条记录，重复以上的判断，直到找到可以访问的数据。</p><p>read committed 与 repeatable read最大的区别就是生成 ReadView 的时机不同，read committed是在每次查询的时候都会生成一个ReadView， 而repeatable read只在第一次读取数据的时候生成ReadView。</p><p>原文链接: <a href="http://herman7z.site" target="_blank" rel="noreferrer">http://herman7z.site</a></p>',31),d=[r];function o(s,n,p,h,c,_){return a(),i("div",null,d)}const x=e(t,[["render",o]]);export{u as __pageData,x as default};
