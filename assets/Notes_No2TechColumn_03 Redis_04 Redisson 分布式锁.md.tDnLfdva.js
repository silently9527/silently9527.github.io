import{_ as s,c as i,o as a,aa as n}from"./chunks/framework.DOnJscRE.js";const c=JSON.parse('{"title":"04 Redisson 分布式锁","description":"","frontmatter":{"title":"04 Redisson 分布式锁","author":"Herman","updateTime":"2024-08-11 21:34","desc":"分布式锁","categories":"中间件","tags":"redis","outline":"deep"},"headers":[],"relativePath":"Notes/No2TechColumn/03 Redis/04 Redisson 分布式锁.md","filePath":"Notes/No2TechColumn/03 Redis/04 Redisson 分布式锁.md","lastUpdated":1763557014000}'),l={name:"Notes/No2TechColumn/03 Redis/04 Redisson 分布式锁.md"},h=n(`<h3 id="一、redisson-分布式锁的核心思想" tabindex="-1">一、Redisson 分布式锁的核心思想 <a class="header-anchor" href="#一、redisson-分布式锁的核心思想" aria-label="Permalink to &quot;一、Redisson 分布式锁的核心思想&quot;">​</a></h3><p>Redisson 的分布式锁是基于 Redis 的 Lua 脚本和一系列封装良好的 Java 对象来实现的。它解决了原生 Redis 实现分布式锁时可能遇到的许多棘手问题，如原子性、锁续期、可重入等。</p><p>其核心依赖 Redis 的几个特性：</p><ul><li>单线程执行：Redis 是单线程的，这意味着命令是顺序执行的，复杂的多命令操作需要保证原子性。</li><li>Lua 脚本：Redisson 大量使用 Lua 脚本将多个 Redis 命令打包成一个原子操作来执行。</li><li>Hash 数据结构：用于存储锁信息，实现可重入性。</li><li>Pub/Sub 功能：用于实现高效的锁等待通知机制，避免无效的轮询。</li></ul><h3 id="二、加锁流程与解锁" tabindex="-1">二、加锁流程与解锁 <a class="header-anchor" href="#二、加锁流程与解锁" aria-label="Permalink to &quot;二、加锁流程与解锁&quot;">​</a></h3><h4 id="_1-加锁的-lua-脚本" tabindex="-1">1. 加锁的 Lua 脚本 <a class="header-anchor" href="#_1-加锁的-lua-脚本" aria-label="Permalink to &quot;1. 加锁的 Lua 脚本&quot;">​</a></h4><p>核心的加锁逻辑是通过一段 Lua 脚本完成的，这保证了原子性。</p><div class="language-lua vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">lua</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">-- KEYS[1]: 锁的Key名称，比如 &quot;myLock&quot;</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">-- ARGV[1]: 锁的超时时间（毫秒）</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">-- ARGV[2]: 客户端唯一标识（UUID + 线程ID）</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">-- 情况1：锁不存在（第一次加锁）</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (redis.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">call</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;exists&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, KEYS[</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">]) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">==</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">then</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    -- 创建Hash结构，field为客户端ID，value为1（重入次数）</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    redis.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">call</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;hincrby&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, KEYS[</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">], ARGV[</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">], </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    -- 设置锁的过期时间</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    redis.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">call</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;pexpire&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, KEYS[</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">], ARGV[</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">]);</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    return</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> nil</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">-- 加锁成功</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">end</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">-- 情况2：锁已存在，且是当前客户端持有的（重入）</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (redis.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">call</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;hexists&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, KEYS[</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">], ARGV[</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">]) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">==</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">then</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    -- 重入次数 +1</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    redis.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">call</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;hincrby&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, KEYS[</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">], ARGV[</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">], </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    -- 重置过期时间</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    redis.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">call</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;pexpire&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, KEYS[</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">], ARGV[</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">]);</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    return</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> nil</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">-- 重入成功</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">end</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">-- 情况3：锁被其他客户端持有</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">-- 返回锁的剩余存活时间（毫秒）</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> redis.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">call</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;pttl&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, KEYS[</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">]);</span></span></code></pre></div><h4 id="_2-解锁的-lua-脚本" tabindex="-1">2. 解锁的 lua 脚本 <a class="header-anchor" href="#_2-解锁的-lua-脚本" aria-label="Permalink to &quot;2. 解锁的 lua 脚本&quot;">​</a></h4><div class="language-lua vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">lua</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">-- KEYS[1]: 锁的Key名称，比如 &quot;myLock&quot;</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">-- KEYS[2]: 发布订阅的频道名称，用于通知其他等待的客户端</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">-- ARGV[1]: 发布的消息内容（通常是锁释放的通知）</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">-- ARGV[2]: 锁的超时时间（毫秒）</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">-- ARGV[3]: 客户端唯一标识（UUID + 线程ID）</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">-- 步骤1：验证锁的所有权</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (redis.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">call</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;hexists&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, KEYS[</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">], ARGV[</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">3</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">]) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">==</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">then</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    return</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> nil</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;  </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">-- 当前客户端不持有该锁，返回nil表示操作无效</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">end</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">-- 步骤2：减少重入计数</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">local</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> counter1 </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> redis.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">call</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;hincrby&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, KEYS[</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">], ARGV[</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">3</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">], </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">-- 步骤3：判断是否完全释放锁</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (counter1 </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">then</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    -- 情况1：还有重入次数，未完全释放</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    redis.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">call</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;pexpire&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, KEYS[</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">], ARGV[</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">]);  </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">-- 刷新锁的过期时间</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    return</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;  </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">-- 返回0表示重入计数减1，但锁仍被持有</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">else</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    -- 情况2：重入次数为0，完全释放锁</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    redis.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">call</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;del&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, KEYS[</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">]);  </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">-- 删除锁键</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    redis.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">call</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;publish&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, KEYS[</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">], ARGV[</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">]); </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">-- 发布锁释放通知</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    return</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;  </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">-- 返回1表示锁已完全释放</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">end</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">return</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> nil</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;  </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">-- 默认返回（理论上不会执行到这里）</span></span></code></pre></div><h3 id="三、可重入锁实现" tabindex="-1">三、可重入锁实现 <a class="header-anchor" href="#三、可重入锁实现" aria-label="Permalink to &quot;三、可重入锁实现&quot;">​</a></h3><p>可重入锁意味着同一个线程可以多次获取同一把锁而不会造成死锁。Redisson 通过 Redis 的 Hash 结构轻松实现了这一点。 数据结构：</p><ul><li>Key: 锁的名称，如 &quot;myLock&quot;。</li><li>Field: 客户端的唯一标识（UUID + 线程ID），如 &quot;8743c9c0-0795-4907-87fd-a6c966a22852:1&quot;。</li><li>Value: 一个整数值，代表该线程重入的次数。</li></ul><p>工作流程：</p><ul><li>第一次加锁：hset myLock [clientId] 1。value 被设置为 1。</li><li>同一线程再次加锁：在 Lua 脚本中，通过 hexists 发现 field 已存在，于是执行 hincrby myLock [clientId] 1。value 变为 2。</li><li>释放锁：释放锁时，并不是直接删除 Key，而是通过 hincrby 将 value 减 1。</li><li>只有当 value 减到 0 时，才会执行 del 命令真正删除这个锁 Key。</li><li>如果 value 减后大于 0，说明还有嵌套的锁没有释放，只会重置一下过期时间。</li></ul><p>这样就完美地模拟了 JVM 内置锁（synchronized/ReentrantLock）的可重入行为。</p><h4 id="四、看门狗机制-watchdog-——-锁自动续期" tabindex="-1">四、看门狗机制（Watchdog）—— 锁自动续期 <a class="header-anchor" href="#四、看门狗机制-watchdog-——-锁自动续期" aria-label="Permalink to &quot;四、看门狗机制（Watchdog）—— 锁自动续期&quot;">​</a></h4><p>你可能会问：如果我的业务逻辑执行时间超过了设置的锁超时时间怎么办？锁提前释放了，其他客户端就会拿到锁，造成数据混乱。 Redisson 提供了一个优雅的解决方案：看门狗机制。</p><ul><li>触发条件：当你使用 lock() 方法不加参数，或者使用 lock(long leaseTime, TimeUnit unit) 但 leaseTime 为 -1 或 null 时，看门狗会生效。</li></ul><p>工作原理：</p><ul><li>默认的锁超时时间是 30秒。</li><li>加锁成功后，Redisson 会启动一个后台定时任务（看门狗），它每隔 10 秒（锁超时时间的 1/3）检查一次客户端是否还持有这个锁。</li><li>如果客户端仍然持有锁（即主线程业务还没执行完），看门狗就会通过 Lua 脚本重置锁的过期时间，将其再次延长为 30秒。</li><li>这个过程会一直重复，直到客户端主动释放锁（unlock()）或客户端宕机。</li></ul><p>优点：只要 JVM 进程没有崩溃，即使业务执行时间很长，锁也不会因为超时而被意外释放，极大地增强了安全性。</p><div class="language-lua vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">lua</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">private RFuture</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;Boolean&gt;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> tryAcquireOnceAsync</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(long waitTime, long leaseTime, TimeUnit unit, long threadId) {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    RFuture</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;Boolean&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> acquiredFuture;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (leaseTime </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        acquiredFuture </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> tryLockInnerAsync</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(waitTime, leaseTime, unit, threadId, RedisCommands.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">EVAL_NULL_BOOLEAN</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    } </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">else</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        acquiredFuture </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> tryLockInnerAsync</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(waitTime, internalLockLeaseTime,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">                TimeUnit.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">MILLISECONDS</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, threadId, RedisCommands.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">EVAL_NULL_BOOLEAN</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    CompletionStage</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;Boolean&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> f </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> acquiredFuture.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">thenApply</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(acquired </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        //</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> lock acquired</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (acquired) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">            if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (leaseTime </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">                internalLockLeaseTime </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> unit.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">toMillis</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(leaseTime);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">            } </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">else</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">                scheduleExpirationRenewal</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(threadId);   </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">//</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">未设置leaseTime的时候启用 watchdog</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">            }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        }</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> acquired;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    });</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> new CompletableFutureWrapper</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(f);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>以下代码就是定时任务执行的逻辑：</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">protected</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> CompletionStage</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">Boolean</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> renewExpirationAsync</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">long</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> threadId) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    return</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> evalWriteAsync</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">getRawName</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(), LongCodec.INSTANCE, RedisCommands.EVAL_BOOLEAN,</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">            &quot;if (redis.call(&#39;hexists&#39;, KEYS[1], ARGV[2]) == 1) then &quot;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> +</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> // 判断当前的锁是否已经释放</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">                    &quot;redis.call(&#39;pexpire&#39;, KEYS[1], ARGV[1]); &quot;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> +</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // 没有释放就重新设置锁的过期时间 internalLockLeaseTime=30s</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">                    &quot;return 1; &quot;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> +</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">                    &quot;end; &quot;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> +</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">                    &quot;return 0;&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">            Collections.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">singletonList</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">getRawName</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()),</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">            internalLockLeaseTime, </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">getLockName</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(threadId));</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><h3 id="五、等待锁的机制" tabindex="-1">五、等待锁的机制 <a class="header-anchor" href="#五、等待锁的机制" aria-label="Permalink to &quot;五、等待锁的机制&quot;">​</a></h3><p>当锁被其他客户端持有时，当前客户端如何等待？</p><ol><li>客户端首先会尝试加锁。</li><li>如果失败，它会订阅一个与锁相关的 Channel。</li><li>然后进入一个循环，在循环中： <ul><li>等待 Channel 上的释放消息。</li><li>一旦收到消息，就再次尝试加锁。</li><li>这个过程中也有超时机制，如果等待时间超过 waitTime 参数，则会放弃加锁。</li></ul></li></ol><p>这种方式比简单的循环 tryLock（自旋）要高效得多，因为它利用了 Redis 的 Pub/Sub 功能，避免了无用的网络请求和 CPU 消耗。</p><blockquote><p>注意：如果你在加锁时显式指定了超时时间（例如 lock.lock(10, TimeUnit.SECONDS)），看门狗机制将不会生效。锁会在 10 秒后自动释放，无论你的业务是否执行完毕。这适用于你能够准确预估业务执行时间的场景。</p></blockquote><h3 id="六、redlock-算法概述" tabindex="-1">六、Redlock 算法概述 <a class="header-anchor" href="#六、redlock-算法概述" aria-label="Permalink to &quot;六、Redlock 算法概述&quot;">​</a></h3><p>Redlock 是 Redis 官方提出的分布式锁算法，用于在多个独立的 Redis 节点上实现更安全的分布式锁。</p><p>核心思想：在 N 个独立的 Redis 主节点 上同时获取锁，当从大多数（N/2 + 1）节点上成功获取锁时，才算真正获取到锁。需要大多数节点确认，避免单点故障、即使部分节点宕机，锁仍然有效</p><blockquote><p>Redisson 的 RedLock 实现提供了生产级别的分布式锁解决方案，特别适合对数据一致性要求极高的场景。</p></blockquote><h3 id="七、读写锁-redissonreadlock、redissonwritelock" tabindex="-1">七、读写锁 RedissonReadLock、RedissonWriteLock <a class="header-anchor" href="#七、读写锁-redissonreadlock、redissonwritelock" aria-label="Permalink to &quot;七、读写锁 RedissonReadLock、RedissonWriteLock&quot;">​</a></h3><h4 id="读写锁规则" tabindex="-1">读写锁规则 <a class="header-anchor" href="#读写锁规则" aria-label="Permalink to &quot;读写锁规则&quot;">​</a></h4><ul><li>读锁（共享锁）：多个线程可以同时持有读锁</li><li>写锁（排他锁）：同一时间只能有一个线程持有写锁</li><li>互斥规则： <ul><li>读锁与写锁互斥</li><li>写锁与写锁互斥</li><li>读锁与读锁不互斥</li></ul></li></ul><h4 id="数据结构" tabindex="-1">数据结构 <a class="header-anchor" href="#数据结构" aria-label="Permalink to &quot;数据结构&quot;">​</a></h4><p>Redisson 使用 Redis 的 Hash 结构来管理读写锁：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>Key: &quot;myLock&quot; (锁名称)</span></span>
<span class="line"><span>Type: Hash</span></span>
<span class="line"><span>Fields:</span></span>
<span class="line"><span>  &quot;mode&quot;: &quot;read&quot;/&quot;write&quot;          # 锁模式</span></span>
<span class="line"><span>  &quot;UUID:threadId:write&quot;: 1         # 写锁持有者（可重入次数）</span></span>
<span class="line"><span>  &quot;UUID:threadId:read&quot;: 2          # 读锁持有者（重入次数）</span></span>
<span class="line"><span>  &quot;latch&quot;: &quot;信号量值&quot;              # 用于同步</span></span></code></pre></div><p>原文链接: <a href="http://herman7z.site" target="_blank" rel="noreferrer">http://herman7z.site</a></p>`,41),k=[h];function p(t,e,E,d,r,g){return a(),i("div",null,k)}const o=s(l,[["render",p]]);export{c as __pageData,o as default};
