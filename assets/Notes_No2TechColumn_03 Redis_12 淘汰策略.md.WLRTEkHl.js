import{_ as e,c as t,o as a,aa as l}from"./chunks/framework.DOnJscRE.js";const y=JSON.parse('{"title":"12 淘汰策略","description":"","frontmatter":{"title":"12 淘汰策略","author":"Herman","updateTime":"2024-08-11 21:34","desc":"淘汰策略","categories":"中间件","tags":"redis","outline":"deep"},"headers":[],"relativePath":"Notes/No2TechColumn/03 Redis/12 淘汰策略.md","filePath":"Notes/No2TechColumn/03 Redis/12 淘汰策略.md","lastUpdated":1764657340000}'),o={name:"Notes/No2TechColumn/03 Redis/12 淘汰策略.md"},i=l('<p>当redis内存超出了物理内存限制时，内存中的数据就会和磁盘开始频繁的交换（swap），交换会让redis的性能急剧下降。为了限制最大使用内存，提供了参数：<code>maxmemory</code>， 当实际内存超过了配置的maxmemory，redis就会采用策略来腾出新的空间。</p><ul><li>noeviction: 不会继续写请求（del除外），只提供读情况，这也是默认的策略</li><li>volatile-lru: 尝试淘汰设置了过期时间的key，最少使用的key优先淘汰，没有设置过期时间不会被淘汰</li><li>volatile-ttl: ttl越小越优先被淘汰, 没有设置过期时间不会被淘汰</li><li>volatile-random: 不过淘汰的 key 是过期 key 集合中随机的 key</li><li>allkeys-lru: 这个策略要淘汰的 key 对象是全体的 key 集合，而不只是过期的 key 集合。这意味着没有设置过期时间的 key 也会被淘汰</li><li>allkeys-random: 这个策略要淘汰的 key 对象是全体的 key 集合, 不过淘汰的策略是随机的 key。</li></ul><p>原文链接: <a href="http://herman7z.site" target="_blank" rel="noreferrer">http://herman7z.site</a></p>',3),r=[i];function s(_,n,d,c,m,p){return a(),t("div",null,r)}const h=e(o,[["render",s]]);export{y as __pageData,h as default};
