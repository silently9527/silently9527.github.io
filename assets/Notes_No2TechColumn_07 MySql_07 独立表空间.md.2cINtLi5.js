import{_ as e,c as l,o as a,aa as t}from"./chunks/framework.DOnJscRE.js";const c=JSON.parse('{"title":"07 独立表空间","description":"","frontmatter":{"title":"07 独立表空间","author":"Herman","updateTime":"2024-08-11 21:34","desc":"Mysql的表空间","categories":"中间件","tags":"MySQL/InnoDB/B+树索引/Mysql的表空间","outline":"deep"},"headers":[],"relativePath":"Notes/No2TechColumn/07 MySql/07 独立表空间.md","filePath":"Notes/No2TechColumn/07 MySql/07 独立表空间.md","lastUpdated":1761383448000}'),r={name:"Notes/No2TechColumn/07 MySql/07 独立表空间.md"},i=t('<h3 id="区的概念" tabindex="-1">区的概念 <a class="header-anchor" href="#区的概念" aria-label="Permalink to &quot;区的概念&quot;">​</a></h3><p>我们知道真实记录是存储在数据页中，如果表中的数据太大，导致表空间中会有很多的页，为了很好的管理这些页，所以又设计了区，每个数据页是16kb，连续的64个页就构成了1个区， 所以1个区的大小是 1M; 表空间就是由若干个区组成的，每256个区被划分为一组。</p><p>为什么要引入区的概念？ 存放记录的数据页之间是通过双向链表链接的，索引中存储目录项的页之间也是通过双向链表链接的，如果两个数据页在物理上离的很远导致，在查询的时候磁头移动的位置很大从而影响性能， 所以才引入了区，区是一片连续的空间，这样可以避免很多的随机IO；每次需要分片新的数据页面时就需要从区从申请；</p><h3 id="段的概念" tabindex="-1">段的概念 <a class="header-anchor" href="#段的概念" aria-label="Permalink to &quot;段的概念&quot;">​</a></h3><p>我们想象一下，在执行B+树查询的时候，如果不区分叶子节点和非叶子节点，所有的节点所代表的页都存放在一起，那么同样会出现很多随机IO影响性能，为了解决这个问题，又引入了段。 存放叶子节点区的集合就称为段，存放非叶子节点的区集合也是一个段。默认情况下创建一个表只有聚簇索引，那么它也有又两个段。</p><p>一个段至少一个区，一个表至少两个段，那么一个表最小也要占用2M，这样对于一下小表来说是不是有点太浪费空间了；所以innodb又引入了碎片区的概念，碎片区存放的数据页可以来自不同 的段，当某个段已经占用了32个碎片区页面之后，他就会自己申请独属于自己段的区，已经占用的碎片区中的页不会重新拷贝。</p><h3 id="区的分类" tabindex="-1">区的分类 <a class="header-anchor" href="#区的分类" aria-label="Permalink to &quot;区的分类&quot;">​</a></h3><ul><li>free: 空闲的区,这个区中没有任何使用的页</li><li>fee_frag: 有剩余空闲页面的碎片区</li><li>full_frag: 没有剩余空闲页面的碎片区</li><li>fseg: 独属于某个段的区</li></ul><p>为了管理好不同类型的区，innodb设计了 xdes_entry 的结构，每个区都对应了一个xdes_entry， 总共占用40个字节，由4部分组成：</p><ul><li>segmentId: 每个段都有个独立的ID，该值表示这个区属于某个段</li><li>list node: 简单理解称两个指针，分别执行前一个区，与后一个区；可以看出区是由list node构成了一条双向链表</li><li>state: 这表示区的状态,可选状态：free, fee_frag, full_frag, fseg</li><li>page state bitmap: 占用16字节，也就是128位；一个区默认由64个页，所以每个页对应2位，其中第一位表示当前是否空闲，第二位还没有使用到。</li></ul><p>当某个段中数据较少的时候，插入数据时，先从表空间中检查是否有状态为fee_frag的区，如果找到了就从该区中取一个页面把数据插入进去，否则从表空间中申请一个状态 为 free的区，把该区变成了一个fee_frag，然后再从新区中取一个页面插入数据。之后不同的段使用零散页都从这个区中取，直到没有了空闲页就把这个区变成full_frag。</p><p>新的问题来了，我们如何知道表空间中哪些区是free、哪些区是full_frag，这时候就需要xdes_entry的list node，表空间中存放了三条链表，这三条链表链接了不同状态的区：</p><ul><li>free 链：空闲区链表</li><li>free_frag 链：有剩余空闲页的区链表</li><li>full_frag 链：没有剩余空间的区链表</li></ul><p>当段已经占用了32个零散页后，段就会申请独属于字节的区，这时候也会建立和表空间类似的三条链表：free链 、 free_frag链 、 full_frag链</p><h3 id="段的结构" tabindex="-1">段的结构 <a class="header-anchor" href="#段的结构" aria-label="Permalink to &quot;段的结构&quot;">​</a></h3><p>每个段都定义了一个 inode_entry 结构</p><ul><li>segmentId: 记录段id</li><li>not_full_n_used: not_full链已经使用了多少个页面</li><li>3个list base node: 分别为段的free链表，not_free链表，full链表，记录这三个链表的表头</li></ul><p>原文链接: <a href="http://herman7z.site" target="_blank" rel="noreferrer">http://herman7z.site</a></p>',18),o=[i];function n(_,s,f,d,p,u){return a(),l("div",null,o)}const m=e(r,[["render",n]]);export{c as __pageData,m as default};
