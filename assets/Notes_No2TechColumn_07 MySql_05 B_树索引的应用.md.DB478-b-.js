import{_ as s,c as i,o as a,aa as l}from"./chunks/framework.DOnJscRE.js";const o=JSON.parse('{"title":"05 B+树索引的应用","description":"","frontmatter":{"title":"05 B+树索引的应用","author":"Herman","updateTime":"2024-08-11 21:34","desc":"B+树索引","categories":"中间件","tags":"MySQL/InnoDB/B+树索引","outline":"deep"},"headers":[],"relativePath":"Notes/No2TechColumn/07 MySql/05 B+树索引的应用.md","filePath":"Notes/No2TechColumn/07 MySql/05 B+树索引的应用.md","lastUpdated":1761366074000}'),h={name:"Notes/No2TechColumn/07 MySql/05 B+树索引的应用.md"},t=l(`<h3 id="索引的代价" tabindex="-1">索引的代价 <a class="header-anchor" href="#索引的代价" aria-label="Permalink to &quot;索引的代价&quot;">​</a></h3><p>索引在空间和时间上都会有代价</p><ul><li>空间上的代价：这是显而易见的，每创建一个索引，都需要为它创建一个B+树，每个B+树的节点都是一个数据页</li><li>时间上的代价：每对表中的数据做增删改操作时，都需要修改各个B+树索引，影响操作效率；每次查找通常来说只能使用到一个索引，如果建太多索引，那么在查询的时候分析过程会耗时太多</li></ul><p>所以我们需要创建又少又号的索引。</p><h3 id="扫描区间和边界条件" tabindex="-1">扫描区间和边界条件 <a class="header-anchor" href="#扫描区间和边界条件" aria-label="Permalink to &quot;扫描区间和边界条件&quot;">​</a></h3><p>在使用某个索引执行查询的时候，关键的问题就是通过查询条件找出合适的扫描区间，然后再到对应的B+树中扫描索引列值在这些区间的记录。对于适合的区间来说， 只需要通过B+树定位到区间最左边的第一个值，就可以沿着链表向右查找出所有的记录满足条件的记录。</p><ul><li>IN操作和若干个等值操作操作符之间用 OR 连接，都会产生多个单点区间</li><li>!=a 操作符产生的区间是 (-∞,&#39;a&#39;) 和 (&#39;a&#39;, +∞)</li><li>like 操作符只能匹配 完整字符串 或者 匹配字符串前缀</li></ul><p>如何从复杂的搜索条件中找出区间，比如：</p><div class="language-sql vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">sql</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">select</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> *</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> from</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> single_table </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">where</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(key1 </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;xyz&#39;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> and</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> key2 </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 748</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">or</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> </span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(key1 </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;abc&#39;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> and</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> key1 </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;1mn&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">or</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> </span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(key1 </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">like</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;%suf&#39;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> and</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> key1 </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;zzz&#39;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> and</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (key2 </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 8000</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> or</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> common_field </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;abc&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">))</span></span></code></pre></div><ol><li>假如使用 key1 作为索引查询，直接简化查询条件，把使用key2的条件替换成true</li></ol><div class="language-sql vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">sql</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(key1 </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;xyz&#39;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> and</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> true) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">or</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> </span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(key1 </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;abc&#39;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> and</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> key1 </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;1mn&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">or</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> </span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(key1 </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">like</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;%suf&#39;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> and</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> key1 </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;zzz&#39;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> and</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> true)</span></span></code></pre></div><p>继续简化，把不能识别出区间的条件去掉，由于 (key1 &lt; &#39;abc&#39; and key1 &gt; &#39;1mn&#39;) 结果为false也可以去掉</p><div class="language-sql vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">sql</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(key1 </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;xyz&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">or</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (key1 </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;zzz&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>由于使用的是 or 连接，所以最终取最大区间也就是 <code>key1 &gt; &#39;xyz&#39;</code>, 这就是使用key1作为查询索引的扫描范围；</p><ol start="2"><li>假如使用 key2 作为索引查询，直接简化查询条件，把使用key1的条件替换成true</li></ol><div class="language-sql vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">sql</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(true </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">and</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> key2 </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 748</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">or</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> true </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">or</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (true </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">and</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (key2 </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 8000</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> or</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> true))</span></span></code></pre></div><p>继续简化后</p><div class="language-sql vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">sql</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">key2 </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 748</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> or</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> true</span></span></code></pre></div><p>最终使用key2作为索引扫描的区间是 (-∞, +∞)</p><p>所以最后Mysql会选择使用key1作为所以查询。</p><blockquote><p><code>key1 like &#39;%suf&#39;</code> 这个条件虽然不能减少扫描的结果，但可以直接在key1的索引中判断出来结果，过滤出不满足条件的记录，减少回表操作，这种优化方式叫做索引下推</p></blockquote><h3 id="索引用于排序" tabindex="-1">索引用于排序 <a class="header-anchor" href="#索引用于排序" aria-label="Permalink to &quot;索引用于排序&quot;">​</a></h3><ul><li>使用联合索引排序时，如果左边的查询条件是常量，可以使用右边的字段进行排序，比如：</li></ul><div class="language-sql vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">sql</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">select</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> *</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> from</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> single_table </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">where</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> where</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> key1 </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;a&#39;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> and</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> key2</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;b&#39;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> order by</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> key3 </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">limit</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 10</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span></code></pre></div><p>不可以使用索引排序的几种情况：</p><ul><li>在同一排序中对不同的字段使用不同的排序方式，ASC、DESC混用；在使用联合索引排序的时候，要求各个字段的排序是一致的。</li><li>排序列中包含了非同一个索引中的列,</li></ul><div class="language-sql vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">sql</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">select</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> *</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> from</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> single_table order key1, key2 </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">limit</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 10</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span></code></pre></div><p>这里key1,key2是两个不同的索引，同时参与排序的话将不会使用到索引</p><ul><li>排序的列是联合索引中的列，但是字段不连续，这时候不能使用到索引</li></ul><div class="language-sql vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">sql</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">select</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> *</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> from</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> single_table </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">order by</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> key1, key3 </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">limit</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 10</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span></code></pre></div><ul><li>用来形成扫描区间的列与排序的列不在同一索引</li></ul><div class="language-sql vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">sql</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">select</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> *</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> from</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> single_table </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">where</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> key1</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;1&#39;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> order by</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> key2 </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">limit</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 10</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span></code></pre></div><ul><li>排序的列必须以单独的列名的形式出现，不能够条件函数，或者做逻辑计算</li></ul><div class="language-sql vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">sql</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">select</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> *</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> from</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> single_table </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">order by</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> upper</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(key1) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">limit</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 10</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span></code></pre></div><h3 id="使用索引分组" tabindex="-1">使用索引分组 <a class="header-anchor" href="#使用索引分组" aria-label="Permalink to &quot;使用索引分组&quot;">​</a></h3><p>分组与排序差不多，分组的列的顺序必须与索引的顺序一致；也可以只使用索引左边连续的列进行分组。</p><h3 id="回表" tabindex="-1">回表 <a class="header-anchor" href="#回表" aria-label="Permalink to &quot;回表&quot;">​</a></h3><p>需要执行回表的操作记录越多，使用二级索引进行查询的性能也就越低，导致某些查询操作宁愿使用全表扫描也不使用二级索引，比如需要查询索引90%的记录然后进行回表操作，那还不如直接使用全表扫描； 一般情况下我们可以给查询语句添加上limit来限制查询的数量，这样有可能会让mysql使用二级索引+回表的操作来查询。</p><p>需要对查询结果进行排序，如果使用二级索引查询需要执行的回表记录太多，也不会使用到索引</p><div class="language-sql vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">sql</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">select</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> *</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> from</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> single_table </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">order by</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> key1;</span></span></code></pre></div><h3 id="更好的创建索引" tabindex="-1">更好的创建索引 <a class="header-anchor" href="#更好的创建索引" aria-label="Permalink to &quot;更好的创建索引&quot;">​</a></h3><ul><li>只为搜索，排序，分组的列创建索引</li><li>考虑索引列中不重复值的个数占全部记录条数的比例，如果比例太低，使用二级索引+回表的方式，就有可能执行太多次的回表操作</li><li>索引列的类型尽量要小；索引列越小，单页存放的记录越多，磁盘io带来的性能损耗越小</li><li>为列前缀建立索引，如果某个字符串列很长，可以给这个列建立前缀索引</li></ul><div class="language-sql vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">sql</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">alter</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> table</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> single_tale </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">add</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> index</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> idx_key1(key1(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">10</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">))</span></span></code></pre></div><ul><li>覆盖索引：对于查询语句返回的字段较少的情况，可以把返回的字段添加到索引里面，这样就可以告别回表操作</li></ul><p>原文链接: <a href="http://herman7z.site" target="_blank" rel="noreferrer">http://herman7z.site</a></p>`,45),k=[t];function e(n,p,d,r,g,E){return a(),i("div",null,k)}const c=s(h,[["render",e]]);export{o as __pageData,c as default};
