import{_ as s,c as a,o as n,aa as p}from"./chunks/framework.DOnJscRE.js";const g=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"Notes/No2TechColumn/06 Kotlin/09 重载算数运算符.md","filePath":"Notes/No2TechColumn/06 Kotlin/09 重载算数运算符.md","lastUpdated":1761049051000}'),t={name:"Notes/No2TechColumn/06 Kotlin/09 重载算数运算符.md"},e=p(`<p>在Java中我们只能够对基础数据类型使用算术运算符(<code>+、-、*、/</code>), 而在Kotlin中可以根据自己的需求对任何对象进行算术运算, 比如 <code>BigDecimal</code>,</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>val a = BigDecimal(&quot;2&quot;)</span></span>
<span class="line"><span>val b = BigDecimal(&quot;2&quot;)</span></span>
<span class="line"><span>print(a + b)</span></span></code></pre></div><p>从上面的代码可以看到我们之间使用的+对两个BigDecimal进行求和, 这样比直接调用<code>add</code>更加直接, 同时也直接 <code>+=</code>.</p><h4 id="二元算术运算" tabindex="-1">二元算术运算 <a class="header-anchor" href="#二元算术运算" aria-label="Permalink to &quot;二元算术运算&quot;">​</a></h4><p>这里我们定义一个<code>Point</code>类</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>data class Point(val x: Int, val y: Int)</span></span></code></pre></div><p>接下来我们就看看如何实现对普通对象进行二元运算, 实现两个点相加, 在Point类中添加plus方法</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>data class Point(val x: Int, val y: Int) {</span></span>
<span class="line"><span>    operator fun plus(point: Point): Point {</span></span>
<span class="line"><span>        return Point(x + point.x, y + point.y)</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span>}</span></span></code></pre></div><p>这里使用的关键字<code>operator</code>, 用来表示这个plus方法作为约定实现,不是碰巧定义了相同的方法名. 除了定义成成员函数也可以把plus定义成扩展函数. 然后来测试下我们的重载是否生效</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>fun main() {</span></span>
<span class="line"><span>    val p1 = Point(10, 20)</span></span>
<span class="line"><span>    val p2 = Point(10, 20)</span></span>
<span class="line"><span>    print(p1 + p2)</span></span>
<span class="line"><span>}</span></span></code></pre></div><p>输出正确</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>Point(x=20, y=40)</span></span></code></pre></div><p>Kotlin允许重载的二元算术运算符的约定函数名</p><table><thead><tr><th>表达式</th><th>函数名</th></tr></thead><tbody><tr><td>a * b</td><td>times</td></tr><tr><td>a / b</td><td>div</td></tr><tr><td>a % b</td><td>mod</td></tr><tr><td>a + b</td><td>plus</td></tr><tr><td>a - b</td><td>minus</td></tr></tbody></table><p>我们在定义一个运算符的时候,允许两个运算对象是不同的类型,比如我们定一个运算符来把一个点放大</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>data class Point(val x: Int, val y: Int) {</span></span>
<span class="line"><span>    operator fun plus(point: Point): Point {</span></span>
<span class="line"><span>        return Point(x + point.x, y + point.y)</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    operator fun times(scale: Double): Point {</span></span>
<span class="line"><span>        return Point((x * scale).toInt(), (y * scale).toInt())</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span>
<span class="line"><span>fun main() {</span></span>
<span class="line"><span>    print(Point(10, 20) * 2.0)</span></span>
<span class="line"><span>}</span></span></code></pre></div><blockquote><p>Kotlin运算符不支持自动交换运算符的左右两边, 若我们需要支持<code>2.0 * Point</code> 需要给Double添加扩展函数</p></blockquote><h4 id="复合赋值运算符" tabindex="-1">复合赋值运算符 <a class="header-anchor" href="#复合赋值运算符" aria-label="Permalink to &quot;复合赋值运算符&quot;">​</a></h4><p>当我们定义了plus这样的运算符函数后, 就已经支持 <code>+=</code> 这种复合赋值操作了</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>var p1 = Point(10, 20)</span></span>
<span class="line"><span>p1 += Point(10, 20)</span></span>
<span class="line"><span>print(p1)</span></span></code></pre></div><p>有些时候, 复合赋值运算符不会创建新的对象,直接在原对象上修改,比如集合添加元素操作</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>val numbers = ArrayList&lt;Int&gt;()</span></span>
<span class="line"><span>numbers += 10</span></span></code></pre></div><p>除了定义 plus 函数在实现复合赋值操作, 还可以通过定义函数名 <code>plusAssign</code> 返回值Unit来实现复合赋值操作, 其他的二元算术运算符也有类似的名字, <code>timesAssign</code> <code>minusAssign</code>, 下面来看看集合是如何实现的 plusAssign</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>public inline operator fun &lt;T&gt; MutableCollection&lt;in T&gt;.plusAssign(element: T) {</span></span>
<span class="line"><span>    this.add(element)</span></span>
<span class="line"><span>}</span></span></code></pre></div><blockquote><p>注意: 若在代码中同时都实现了<code>plus</code> <code>plusAssign</code>, 当用到了<code>+=</code>的时候理论上来说都会被调用,编译器这时候会报错. 最好是不要给同一个类同时实现这两个方法. 例如上面的Point例子,这个类是不可变的就应该只提供一个返回一个新值(plus), 如果这个类是可变的,比如集合,那么应该提供<code>plusAssign</code></p></blockquote><p>原文链接: <a href="http://herman7z.site" target="_blank" rel="noreferrer">http://herman7z.site</a></p>`,26),i=[e];function l(o,c,d,r,u,h){return n(),a("div",null,i)}const v=s(t,[["render",l]]);export{g as __pageData,v as default};
