import{_ as e,c as t,o as r,aa as a}from"./chunks/framework.DOnJscRE.js";const f=JSON.parse('{"title":"09 管道","description":"","frontmatter":{"title":"09 管道","author":"Herman","updateTime":"2024-08-11 21:34","desc":"管道","categories":"中间件","tags":"redis","outline":"deep"},"headers":[],"relativePath":"Notes/No2TechColumn/03 Redis/09 管道.md","filePath":"Notes/No2TechColumn/03 Redis/09 管道.md","lastUpdated":1764575787000}'),i={name:"Notes/No2TechColumn/03 Redis/09 管道.md"},l=a('<h3 id="管道" tabindex="-1">管道 <a class="header-anchor" href="#管道" aria-label="Permalink to &quot;管道&quot;">​</a></h3><p><img src="https://raw.githubusercontent.com/silently9527/images/main/20251201153915014.png" alt=""></p><p>先来深入了解下请求交互的过程，</p><ol><li>客户端进程调用 write 将消息写到操作系统内核为套接字分配的发送缓冲 send buffer。</li><li>客户端操作系统内核将发送缓冲的内容发送到网卡，网卡硬件将数据通过「网际路由」送到服务器的网卡。</li><li>服务器操作系统内核将网卡的数据放到内核为套接字分配的接收缓冲 recv buffer。</li><li>服务器进程调用 read 从接收缓冲中取出消息进行处理。</li><li>服务器进程调用 write 将响应消息写到内核为套接字分配的发送缓冲 send buffer。</li><li>服务器操作系统内核将发送缓冲的内容发送到网卡，网卡硬件将数据通过「网际路由」送到客户端的网卡。</li><li>客户端操作系统内核将网卡的数据放到内核为套接字分配的接收缓冲 recv buffer。</li><li>客户端进程调用 read 从接收缓冲中取出消息返回给上层业务逻辑进行处理。</li><li>结束。</li></ol><p>在这个过程中重点关注 write 和 read ； write主要是将数据写入到操作系统内核的发送缓冲区就返回了，剩下的操作都是交给了操作系统异步完成的，如果缓冲区满了，write方法就会阻塞等待，这才是写操作真正的耗时情况。read操作只负责从操作系统内核缓存区中取出数据， 如何缓存区是空的，read就会阻塞等待，这是读操作真正耗时的情况</p><p>管道的本质就是客户端通过对管道中的指令列表改变读写顺序，把全部的write放在一起连续操作，read放到一起操作就可以大幅节省 IO 时间，服务器根本没有任何区别对待，还是收到一条消息，执行一条消息，回复一条消息的正常的流程。</p><p>对于管道来说，连续的write 操作根本就没有耗时，之后第一个read 操作会等待一个网络的来回开销，然后所有的响应消息就都已经回送到内核的读缓冲了，后续的 read 操作直接就可以从缓冲拿到结果，瞬间就返回了。</p><p>原文链接: <a href="http://herman7z.site" target="_blank" rel="noreferrer">http://herman7z.site</a></p>',8),o=[l];function s(n,d,_,c,p,h){return r(),t("div",null,o)}const u=e(i,[["render",s]]);export{f as __pageData,u as default};
