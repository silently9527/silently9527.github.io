import{_ as a,c as s,o as n,aa as e}from"./chunks/framework.DOnJscRE.js";const m=JSON.parse('{"title":"06 Lambda","description":"","frontmatter":{"title":"06 Lambda","author":"Herman","updateTime":"2024-09-18 12:34","desc":"Kotlin 基础入门","categories":"Kotlin","tags":"Kotlin","outline":"deep"},"headers":[],"relativePath":"Notes/No2TechColumn/06 Kotlin/06 Lambda.md","filePath":"Notes/No2TechColumn/06 Kotlin/06 Lambda.md","lastUpdated":1761052119000}'),p={name:"Notes/No2TechColumn/06 Kotlin/06 Lambda.md"},t=e(`<p>在前面的内容中我们曾用匿名内部类的形式实现了按钮button的点击事件监听,其实还有一种更加简单的方式,就是使用lambda表达式. lambda就是允许把函数当作值来对待,可以直接传递函数,而不需要声明一个类再传递这个类的实例</p><h4 id="lambda表达式的语法" tabindex="-1">Lambda表达式的语法 <a class="header-anchor" href="#lambda表达式的语法" aria-label="Permalink to &quot;Lambda表达式的语法&quot;">​</a></h4><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>fun main(args: Array&lt;String&gt;) {</span></span>
<span class="line"><span>    val sum = { x: Int, y: Int -&gt; x + y }</span></span>
<span class="line"><span>    println(sum(1, 2))</span></span>
<span class="line"><span>}</span></span></code></pre></div><p>Lambda表达式使用花括号包围起来, 参数并没有使用括号包起来,使用 <code>-&gt;</code> 把参数和函数体隔开</p><p>继续来看个例子, 我们有个Person集合, 需要从集合中找出年龄最大的</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>data class Person(val name: String, val age: Int)</span></span>
<span class="line"><span></span></span>
<span class="line"><span>fun main(args: Array&lt;String&gt;) {</span></span>
<span class="line"><span>    val persons = listOf(Person(&quot;Herman&quot;, 20), Person(&quot;Pitt&quot;, 35), Person(&quot;Taomm&quot;, 20))</span></span>
<span class="line"><span>    println(persons.maxByOrNull( { person: Person -&gt; person.age }))</span></span>
<span class="line"><span>}</span></span></code></pre></div><p>maxByOrNull: Kotlin对集合的扩展函数, 接受lambda表达式;</p><p>Kotlin的语法约定:</p><ul><li>当lambda表达式是函数的最后一个函数允许放到括号的外面</li></ul><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>persons.maxByOrNull() { person: Person -&gt; person.age }</span></span></code></pre></div><ul><li>当lambda表达式是函数的唯一参数时,可以去掉空括号</li></ul><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>persons.maxByOrNull { person: Person -&gt; person.age }</span></span></code></pre></div><ul><li>由于Kotlin的编译器能够根据集合元素类型推导出参数类型, 所以可以进一步简化</li></ul><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>persons.maxByOrNull { person -&gt; person.age }</span></span></code></pre></div><ul><li>如果当前的lambda只有一个参数并且参数的类型能够推到出来,kotlin就会默认生成一个参数名<code>it</code>, 所以进一步简化</li></ul><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>persons.maxByOrNull { it.age }</span></span></code></pre></div><ul><li>上面的例子已经比较简洁了, 但其实还有另一种写法</li></ul><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>persons.maxByOrNull(Person::age)</span></span></code></pre></div><p>若你使用参数来存储lambda表达式,那么就必须要指定类型, 比如</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>val getAge = { p: Person -&gt; p.age }</span></span>
<span class="line"><span>persons.maxByOrNull(getAge)</span></span></code></pre></div><blockquote><p>Kotlin中lambda表达式限制访问final变量, 可以在lambda表达式中修改这些变量</p></blockquote><h4 id="集合的函数式api" tabindex="-1">集合的函数式API <a class="header-anchor" href="#集合的函数式api" aria-label="Permalink to &quot;集合的函数式API&quot;">​</a></h4><p>Koltin集合的函数式操作和Java的基本相同, 可以参考以前的文章 <a href="https://herman7z.site/Notes/No2TechColumn/01%20Java/09%20%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E5%AD%A6%E4%B9%A0java8stream%E7%9C%8B%E8%BF%99%E7%AF%87%E5%B0%B1%E5%A4%9F%E4%BA%86.html" target="_blank" rel="noreferrer">从零开始学习java8stream看这篇就够了</a></p><h4 id="序列" tabindex="-1">序列 <a class="header-anchor" href="#序列" aria-label="Permalink to &quot;序列&quot;">​</a></h4><p>在集合的函数式中,我们通常会使用链式调用, 比如map, filter, 每次在调用这函数的Koltin都会去创建中间集合来存储临时结果,为了提高效率可以把操作变成序列,而不直接使用集合; 比如获取所有Person的name</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>val names = persons.asSequence().map(Person::name).toList()</span></span></code></pre></div><p>序列的操作分为中间操作和末端操作, 其中中间操作是惰性的, 把上面的例子修改下:</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>val names = persons.asSequence().map { p -&gt;</span></span>
<span class="line"><span>    println(p.name)</span></span>
<span class="line"><span>    p.name</span></span>
<span class="line"><span>}</span></span></code></pre></div><p>执行这段代码后我们会发现不会打印出任何内容,这是由于中间操作是惰性的,不会去执行; 如果我们把<code>asSequence</code>去掉就可以打印出来.</p><h4 id="with、apply函数" tabindex="-1">with、apply函数 <a class="header-anchor" href="#with、apply函数" aria-label="Permalink to &quot;with、apply函数&quot;">​</a></h4><p>在实际的项目中,经常会对同一个对象进行多次操作,这时候可以使用with函数,可以不用反复把对象名写出来.</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>val name = with(Person(&quot;Herman&quot;, 20)) {</span></span>
<span class="line"><span>    println(name)</span></span>
<span class="line"><span>    println(this.age)</span></span>
<span class="line"><span>    name</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span>println(name)</span></span></code></pre></div><p>在lambda表达式的作用域中,可以直接使用this指针引用Person对象; with函数的返回结果就是lambda表达式的最后一行表达式; 有时候我们需要返回接收对象本身,上面的例子可以直接把<code>name</code>替换成<code>this</code> , 还可以使用apply函数</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>val person = Person(&quot;Herman&quot;, 20).apply {</span></span>
<span class="line"><span>    println(name)</span></span>
<span class="line"><span>    println(this.age)</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span>println(person)</span></span></code></pre></div><p>原文链接: <a href="http://herman7z.site" target="_blank" rel="noreferrer">http://herman7z.site</a></p>`,35),l=[t];function i(o,c,d,r,h,u){return n(),s("div",null,l)}const b=a(p,[["render",i]]);export{m as __pageData,b as default};
